---
phase: 01-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/config.mjs
  - scripts/ado-client.mjs
autonomous: true
requirements:
  - AUTH-02

must_haves:
  truths:
    - "config.mjs reads and writes ~/.adi/config.json with correct file permissions (0o600)"
    - "config.mjs masks PAT values for display — first 4 and last 4 chars visible, rest asterisks"
    - "ado-client.mjs builds correct Basic auth header — colon prefix before PAT, base64 encoded"
    - "validateConnection distinguishes network errors, auth errors (401), and permission errors (403) for both the org and project scopes"
    - "HTTP 203 response from Azure DevOps is treated as an auth error (redirect to login)"
  artifacts:
    - path: "scripts/config.mjs"
      provides: "Config read/write/mask for ~/.adi/config.json"
      exports: ["loadConfig", "saveConfig", "configExists", "maskPat"]
    - path: "scripts/ado-client.mjs"
      provides: "Azure DevOps REST API client with auth and error classification"
      exports: ["adoGet", "validateConnection", "buildAuthHeader"]
  key_links:
    - from: "scripts/ado-client.mjs"
      to: "scripts/config.mjs"
      via: "import { loadConfig } from './config.mjs'"
      pattern: "import.*config\\.mjs"
    - from: "scripts/ado-client.mjs"
      to: "https://dev.azure.com/{org}/_apis/projects"
      via: "validateConnection step 1 — org-level PAT check"
      pattern: "validateConnection"
    - from: "scripts/ado-client.mjs"
      to: "https://dev.azure.com/{org}/{project}/_apis/git/repositories"
      via: "validateConnection step 2 — Code (Read) scope check"
      pattern: "git/repositories"
---

<objective>
Create the two shared scripts that every future skill depends on: `config.mjs` (config read/write/mask) and `ado-client.mjs` (Azure DevOps API client with PAT auth and error classification).

Purpose: These scripts form the shared infrastructure layer. All data scripts in Phases 2-4 will import from these. Getting them right here — especially the PAT encoding, error classification, and HTTP 203 handling — prevents hard-to-debug failures in every subsequent phase.
Output: Two tested ESM modules in `scripts/` using only Node.js built-ins. Zero npm dependencies.
</objective>

<execution_context>
@C:/Users/7N_TSM/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/7N_TSM/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Config manager (config.mjs)</name>
  <files>scripts/config.mjs</files>
  <action>
Create `scripts/config.mjs` as an ESM module (`.mjs` extension, no `"type": "module"` in package.json needed).

Implement these exports exactly:

```javascript
// scripts/config.mjs
import { readFileSync, writeFileSync, mkdirSync } from 'fs';
import { join } from 'path';
import { homedir } from 'os';

const CONFIG_DIR = join(homedir(), '.adi');
const CONFIG_FILE = join(CONFIG_DIR, 'config.json');

export function loadConfig() {
  try {
    return JSON.parse(readFileSync(CONFIG_FILE, 'utf8'));
  } catch {
    throw new Error('Not configured. Run /adi:setup first.\nExpected config at: ' + CONFIG_FILE);
  }
}

export function configExists() {
  try { readFileSync(CONFIG_FILE); return true; } catch { return false; }
}

export function saveConfig(config) {
  mkdirSync(CONFIG_DIR, { recursive: true });
  writeFileSync(CONFIG_FILE, JSON.stringify(config, null, 2), { mode: 0o600 });
}

export function maskPat(pat) {
  if (!pat || pat.length < 8) return '***';
  return pat.slice(0, 4) + '*'.repeat(pat.length - 8) + pat.slice(-4);
}
```

Key implementation notes:
- Use `os.homedir()` — NOT `process.env.HOME` (unreliable on Windows)
- `mkdirSync` with `{ recursive: true }` — idempotent, no race condition, creates silently
- `writeFileSync` with `{ mode: 0o600 }` — owner read-write only on Unix (silently no-ops on Windows)
- `maskPat` shows first 4 and last 4 chars — e.g. `"abcd" + "****...****" + "wxyz"` for a 44-char PAT
- Config path is `~/.adi/config.json` — NOT `~/.ado-insights/` (that was the old name, now changed)
  </action>
  <verify>
    <automated>node --input-type=module --eval "
import { maskPat, saveConfig, loadConfig, configExists } from './scripts/config.mjs';

// Test maskPat
const masked = maskPat('abcdefghijklmnopqrstuvwxyz123456');
console.assert(masked.startsWith('abcd'), 'maskPat: should start with first 4');
console.assert(masked.endsWith('3456'), 'maskPat: should end with last 4');
console.assert(masked.includes('*'), 'maskPat: should have asterisks');

// Test maskPat short
console.assert(maskPat('abc') === '***', 'maskPat: short pat returns ***');
console.assert(maskPat('') === '***', 'maskPat: empty pat returns ***');

console.log('OK: config.mjs exports verified');
"</automated>
    <manual>Confirm scripts/config.mjs exists and uses os.homedir() (not process.env.HOME).</manual>
  </verify>
  <done>config.mjs exports loadConfig, saveConfig, configExists, maskPat. maskPat correctly masks middle chars. CONFIG_FILE resolves to ~/.adi/config.json using os.homedir().</done>
</task>

<task type="auto">
  <name>Task 2: Azure DevOps API client (ado-client.mjs)</name>
  <files>scripts/ado-client.mjs</files>
  <action>
Create `scripts/ado-client.mjs` as an ESM module.

Implement these exports:

```javascript
// scripts/ado-client.mjs
import { loadConfig } from './config.mjs';

const API_VERSION = '7.1';

export function buildAuthHeader(pat) {
  // CRITICAL: colon prefix required for Azure DevOps Basic auth
  // Buffer.from(':' + pat.trim()) — empty username + colon + PAT
  return 'Basic ' + Buffer.from(':' + pat.trim()).toString('base64');
}

export async function adoGet(path, params = {}, configOverride = null) {
  const config = configOverride || loadConfig();
  const base = config.orgUrl.replace(/\/$/, '');
  const url = new URL(`${base}/${config.project}/_apis/${path}`);
  url.searchParams.set('api-version', API_VERSION);
  for (const [k, v] of Object.entries(params)) url.searchParams.set(k, v);

  let response;
  try {
    response = await fetch(url.toString(), {
      headers: {
        'Authorization': buildAuthHeader(config.pat),
        'Content-Type': 'application/json'
      }
    });
  } catch (err) {
    throw Object.assign(new Error('Network error: cannot reach ' + config.orgUrl + '. Check the org URL.'), { type: 'network' });
  }

  if (response.status === 401 || response.status === 203) {
    // 203: Azure DevOps redirects to login page on wrong PAT encoding — treat as auth error
    throw Object.assign(new Error('PAT rejected. The token may be expired, invalid, or wrongly encoded.'), { type: 'auth' });
  }
  if (response.status === 403) {
    throw Object.assign(new Error('PAT lacks required permissions (HTTP 403). Check required scopes in /adi:setup.'), { type: 'permission' });
  }
  if (!response.ok) {
    throw Object.assign(new Error(`Azure DevOps API error: ${response.status} ${response.statusText}`), { type: 'api' });
  }
  return response.json();
}

export async function validateConnection(orgUrl, project, pat) {
  const orgBase = orgUrl.replace(/\/$/, '');
  const headers = { 'Authorization': buildAuthHeader(pat), 'Content-Type': 'application/json' };

  // Step 1: Test org URL reachability + PAT validity (project-agnostic endpoint)
  const projectsUrl = new URL(`${orgBase}/_apis/projects`);
  projectsUrl.searchParams.set('api-version', API_VERSION);
  projectsUrl.searchParams.set('$top', '1');

  let projectsResp;
  try {
    projectsResp = await fetch(projectsUrl.toString(), { headers });
  } catch (err) {
    return { ok: false, type: 'network', message: 'Cannot reach ' + orgUrl + '. Check the org URL and your internet connection.' };
  }

  if (projectsResp.status === 401 || projectsResp.status === 203) {
    return { ok: false, type: 'auth', message: 'PAT rejected. The token may be expired or invalid. Generate a new PAT at: https://dev.azure.com/' + orgUrl.replace(/^https?:\/\/[^/]+\//, '') + '/_usersSettings/tokens' };
  }
  if (projectsResp.status === 403) {
    return { ok: false, type: 'permission', missingScope: 'Project and Team (Read)', message: 'PAT missing "Project and Team (Read)" permission.' };
  }
  if (!projectsResp.ok) {
    return { ok: false, type: 'api', message: `Unexpected response: ${projectsResp.status} ${projectsResp.statusText}` };
  }

  // Step 2: Test project access + Code (Read) scope
  const reposUrl = new URL(`${orgBase}/${project}/_apis/git/repositories`);
  reposUrl.searchParams.set('api-version', API_VERSION);

  let reposResp;
  try {
    reposResp = await fetch(reposUrl.toString(), { headers });
  } catch (err) {
    return { ok: false, type: 'network', message: 'Connected to org but cannot reach project. Check the project name.' };
  }

  if (reposResp.status === 403) {
    return { ok: false, type: 'permission', missingScope: 'Code (Read)', message: 'PAT missing "Code (Read)" permission. Add this scope at: https://dev.azure.com/' + orgUrl.replace(/^https?:\/\/[^/]+\//, '') + '/_usersSettings/tokens' };
  }
  if (reposResp.status === 404) {
    return { ok: false, type: 'not_found', message: 'Project "' + project + '" not found in this org. Check the project name.' };
  }
  if (!reposResp.ok) {
    return { ok: false, type: 'api', message: `Project access check failed: ${reposResp.status} ${reposResp.statusText}` };
  }

  return { ok: true };
}
```

Key implementation notes:
- `buildAuthHeader`: MUST use `':' + pat.trim()` — the leading colon (empty username) is required. Missing it causes HTTP 401 or HTTP 203 (silent redirect to login page). Centralized here so it cannot be duplicated incorrectly.
- HTTP 203 handling: Azure DevOps sometimes returns 203 (redirect to login) instead of 401 when PAT encoding is wrong. `response.ok` is true for 203, so explicit check needed.
- `validateConnection` makes two sequential calls: (1) org-level `_apis/projects` to verify URL + PAT, (2) project-level `git/repositories` to verify `Code (Read)` scope. Maps each failure to a human-readable message.
- API_VERSION constant (`'7.1'`) — never inline the version string.
- `adoGet` uses `config.project` in the URL path — appropriate for project-scoped endpoints. The `validateConnection` function constructs URLs manually because it needs org-level and project-level endpoints separately.
  </action>
  <verify>
    <automated>node --input-type=module --eval "
import { buildAuthHeader } from './scripts/ado-client.mjs';

// Test PAT encoding — must include colon prefix
const header = buildAuthHeader('mypat');
const decoded = Buffer.from(header.replace('Basic ', ''), 'base64').toString('utf8');
console.assert(decoded === ':mypat', 'PAT must be encoded as :pat (colon prefix). Got: ' + decoded);

// Test trim behavior
const headerWithSpaces = buildAuthHeader('  mypat  ');
const decodedTrimmed = Buffer.from(headerWithSpaces.replace('Basic ', ''), 'base64').toString('utf8');
console.assert(decodedTrimmed === ':mypat', 'PAT must be trimmed. Got: ' + decodedTrimmed);

console.log('OK: ado-client.mjs PAT encoding verified');
"</automated>
    <manual>Confirm scripts/ado-client.mjs exists. Check that buildAuthHeader uses Buffer.from(':' + pat.trim()) and that validateConnection makes two sequential fetch calls.</manual>
  </verify>
  <done>ado-client.mjs exports buildAuthHeader, adoGet, validateConnection. buildAuthHeader correctly prepends colon before PAT. validateConnection makes two sequential API calls and returns typed error objects distinguishing network/auth/permission/not_found errors. HTTP 203 is treated as auth error.</done>
</task>

</tasks>

<verification>
Run both automated verify commands — all assertions pass.
Check `scripts/config.mjs` uses `os.homedir()` (not `process.env.HOME`).
Check `scripts/ado-client.mjs` has `response.status === 203` in the auth error check.
Check `buildAuthHeader` uses `':' + pat.trim()` — the colon prefix is critical.
</verification>

<success_criteria>
1. `config.mjs` reads/writes `~/.adi/config.json`, masks PATs correctly, creates directory silently.
2. `ado-client.mjs` encodes PATs with colon prefix, handles HTTP 203 as auth error, distinguishes network/auth/permission failures in validateConnection.
3. Both modules use only Node.js built-in APIs — no npm dependencies.
4. PAT encoding test passes: decoded header starts with `:`.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md` documenting:
- The exports from each module
- The HTTP 203 handling decision
- The two-step validateConnection design (org-level then project-level)
- Any deviations from the research patterns
</output>
